#include <iostream>
#include <limits.h>
using namespace std;

/*Дадена е m x n  матрица от числа (пр. 7x8)
Дадена е подматрица k x k, k <= min(m,n) (пр. 3x3)
Да се намери максималната сума от елементи k x k в m x n (пр. кои 3x3 числа сумарно дават макимален резултат).
Вход: m,n, k
Изход: maxSum*/

int main()
{
    // При предварително въведени стойности:
    // int m = 5;
    // int n = 7;
    // int k = 3;
    // int matrix[m][n] = {{1, 2, 3, 4, 5, 6, 7}, {11, 12, 13, 14, 15, 16, 17}, {21, 22, 23, 24, 25, 26, 27}, {31, 32, 33, 34, 35, 36, 37}, {41, 42, 43, 44, 45, 46, 47}};

    // При неизвестни стойности, които следва да се въведат от потребителя:
    int m, n, k;

    // do-while цикълите продължават, докато не се въведат валидни стойности:
    do
    {
        cout << "How many rows(m) will the matrix be?: ";
        cin >> m;
    } while (m < 1);
    do
    {
        cout << "How many columns(n) will the matrix be?: ";
        cin >> n;
    } while (n < 1 && k > m && k > n);
    do
    {
        cout << "Enter submatrix size(k): ";
        cin >> k;
    } while (k > m && k > n);

    int **matrix = new int *[m]; // може да бъде заменено с int matrix[100][100]; и нуждата от for отпада.
    for (int i = 0; i < m; i++)
    {
        matrix[i] = new int[n];
    }

    for (int i = 0; i < m; i++) // Въвеждаме стойностите на елементите от основната матрица.
    {
        cout << "Enter Values for row " << i + 1 << ": \n";
        for (int j = 0; j < n; j++)
        {
            cin >> matrix[i][j];
        }
    }
    cout << endl;

    int subMatrix[k][k];  // Инициализираме подматрицата с въведените стойности за k.
    int maxSum = INT_MIN; // Създаваме контейнер за съхранение на най-голямата сума.
    int currentSum = 0;   // Съхраняваме настоящата сума от subMatrix[k][k]

    for (int i = 0; i < m - (k - 1); i++) // Редове на основаната матрица. Цикълът ще се изпълнява до m - (k - 1), за да се обходят целите редове, но без да се излиза от матрицата.
    {
        for (int j = 0; j < n - (k - 1); j++) // Колони на основаната матрица. Цикълът ще се изпълнява до n - (k - 1), за да се обходят всички колони, но без да се излиза от матрицата.
        {
            for (int i2 = i; i2 < i + k; i2++) // Редове на подматрицата. Цикълът ще се изпълнява от настоящата стойност на i до k елемента след настоящата стойност на i.
            {
                for (int j2 = j; j2 < j + k; j2++) // Колони на подматрицата. Цикълът ще се изпълнява от настоящата стойност на j до k елемента след настоящата стойност на j.
                {

                    cout << matrix[i2][j2] << " "; // Извеждане на елементите на subMatrix[k][k]
                    currentSum += matrix[i2][j2];  // Добавяме всеки елемент от subMatrix[k][k] към настоящата сума.
                }
                cout << endl; // нов ред след всeки matrix[i2][j2] за пригледност.
            }

            if (maxSum < currentSum) // Ако настоящата сума на елементите от subMatrix[k][k] е по-голяма от сумата в контейнера maxSum, то тя става неговата нова стойност.
                maxSum = currentSum;

            cout << "currentSum: " << currentSum << endl;
            currentSum = 0; // Нулираме резултата за настояща сума, за да може изчислнието на следващата сума на subMatrix[k][k] да започне от нула.

            cout << endl; // нов ред след всяка subMatrix[k][k] за пригледност.
        }
    }

    cout << "maxSum: " << maxSum << endl; // След като сме обходили всички subMatrix[k][k] на matrix[m][n] и сме сравнили сумите на елементите в подматрицата, извеждаме най-голямата запазена сума.

    return 0;
}